# 0-1 背包问题多算法性能对比实验

## 实验目的

- 掌握0-1背包问题的蛮力法、动态规划法、贪心法和回溯法的基本思想及C语言实现。
- 比较不同算法在不同输入规模下的运行效率和结果差异，理解算法复杂度和适用场景。
- 培养算法设计、性能分析和实验总结能力。

## 实验内容

1. **数据准备**
   - 小规模（n≤20）和n=1000时，分别用随机生成和CSV文件读取物品数据。
   - 大规模（n>1000）用随机生成数据。

2. **算法实现**
   - 蛮力法（Brute Force）
   - 动态规划法（Dynamic Programming）
   - 贪心法（Greedy）
   - 回溯法（Backtracking）

3. **实验分组**
   - 小规模（n≤20）：四种算法全部运行。
   - 大规模（n>20）：只运行动态规划法和贪心法。

4. **性能测试**
   - 记录每种算法在不同物品数量和背包容量下的运行时间、总价值和总重量。

5. **结果分析**
   - 对比不同算法的性能和结果，分析其适用范围和效率。

## 使用方法

1. **准备数据**
   - 若n=1000，需提前准备`items_1000.csv`，格式为：物品编号,物品重量,物品价值。
   - 其他规模自动随机生成数据。

2. **编译运行**
   - Windows下建议用VS或gcc编译：
     ```
     gcc main.c -o knapsack -lkernel32
     ```
   - 运行程序，结果会在控制台输出。

3. **输出说明**
   - 每组实验输出各算法的总价值、总重量、选择物品数量和运行时间（ms）。

## 主要文件说明

- `main.c`：主程序，包含数据生成、四种算法实现、性能测试与结果输出。
- `items_1000.csv`：n=1000时的物品数据文件（需自行生成）。

## 注意事项

- 蛮力法和回溯法只适合小规模（n≤20），大规模下会极慢或无法运行。
- 动态规划法和贪心法可用于大规模，但DP法在超大规模时内存消耗较大。
- 若出现内存分配失败或越界提示，请适当减小n或W。

## 实验结论简述

- 蛮力法、动态规划法、回溯法在小规模下结果一致，验证正确性。
- 贪心法速度快，结果接近最优，适合大规模近似求解。
- 动态规划法结果最优，适合中等规模。
- 大规模下只推荐用动态规划法和贪心